"""
Tests for the favorites functionality bug fix.

This test ensures that the data-favorite-url attribute is properly included
in the cocktail detail template and that the favorites AJAX endpoint works correctly.

Bug: The JavaScript was constructing incorrect URLs (e.g., /cocktails/440/favorite/ 
instead of /cocktails/40/favorite/) leading to 404 errors.

Fix: Use Django's URL template tag to generate the correct URL in the template
and pass it via data-favorite-url attribute to the JavaScript.
"""

from django.test import TestCase, Client
from django.contrib.auth.models import User
from django.urls import reverse
from bs4 import BeautifulSoup
from ..models import Cocktail, Ingredient, Vessel, RecipeComponent, List


class FavoritesBugFixTest(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(username='testuser', password='testpass123')
        
        # Create test data
        self.vessel = Vessel.objects.create(name='Highball Glass', volume=300, material='Glass')
        self.ingredient = Ingredient.objects.create(
            name='Test Gin', 
            ingredient_type='spirit', 
            alcohol_content=40.0
        )
        self.cocktail = Cocktail.objects.create(
            name='Test Gin & Tonic',
            instructions='Mix and serve over ice',
            creator=self.user,
            vessel=self.vessel
        )
        RecipeComponent.objects.create(
            cocktail=self.cocktail,
            ingredient=self.ingredient,
            amount=50.0,
            unit='ml',
            order=1
        )

    def test_cocktail_detail_template_includes_favorite_url_data_attribute(self):
        """
        Test that the cocktail detail template includes the data-favorite-url attribute
        with the correct URL generated by Django's URL template tag.
        """
        self.client.login(username='testuser', password='testpass123')
        
        # Get the cocktail detail page
        response = self.client.get(reverse('cocktail_detail', args=[self.cocktail.id]))
        self.assertEqual(response.status_code, 200)
        
        # Parse the HTML content
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Find the favorite button
        favorite_button = soup.find('button', {'id': 'favorite-btn'})
        self.assertIsNotNone(favorite_button, "Favorite button should exist in the template")
        
        # Check that it has the correct data attributes
        self.assertEqual(
            favorite_button.get('data-cocktail-id'), 
            str(self.cocktail.id),
            "Button should have correct cocktail ID"
        )
        
        expected_url = reverse('toggle_favorite', args=[self.cocktail.id])
        self.assertEqual(
            favorite_button.get('data-favorite-url'),
            expected_url,
            "Button should have correct favorite URL from Django URL template tag"
        )

    def test_favorites_ajax_endpoint_works_correctly(self):
        """
        Test that the toggle_favorite endpoint works correctly for the specific 
        cocktail ID that was causing issues in the bug report.
        """
        self.client.login(username='testuser', password='testpass123')
        
        # Test with cocktail ID 40 (the one from the bug report)
        # Create a cocktail with ID that might cause URL construction issues
        cocktail_40 = Cocktail.objects.create(
            name='Cocktail 40',
            instructions='Test cocktail',
            creator=self.user,
            vessel=self.vessel,
            id=40  # Explicitly set ID to test edge case
        )
        
        # First request - should add to favorites
        response = self.client.post(
            reverse('toggle_favorite', args=[cocktail_40.id]),
            HTTP_X_REQUESTED_WITH='XMLHttpRequest'
        )
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertTrue(data['success'])
        self.assertTrue(data['favorited'])
        self.assertIn('added', data['message'])
        
        # Verify it was added to favorites
        favorites_list = List.get_or_create_favorites_list(self.user)
        self.assertIn(cocktail_40, favorites_list.cocktails.all())
        
        # Second request - should remove from favorites
        response = self.client.post(
            reverse('toggle_favorite', args=[cocktail_40.id]),
            HTTP_X_REQUESTED_WITH='XMLHttpRequest'
        )
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertTrue(data['success'])
        self.assertFalse(data['favorited'])
        self.assertIn('removed', data['message'])
        
        # Verify it was removed from favorites
        self.assertNotIn(cocktail_40, favorites_list.cocktails.all())

    def test_favorites_url_construction_edge_cases(self):
        """
        Test that the URL construction works correctly for various cocktail IDs
        that might have caused issues in the original bug.
        """
        self.client.login(username='testuser', password='testpass123')
        
        # Test with various IDs that might cause string concatenation issues
        test_ids = [40, 440, 123, 1, 9999]
        
        for test_id in test_ids:
            with self.subTest(cocktail_id=test_id):
                # Create cocktail with specific ID
                cocktail = Cocktail.objects.create(
                    name=f'Test Cocktail {test_id}',
                    instructions='Test',
                    creator=self.user,
                    vessel=self.vessel,
                    id=test_id
                )
                
                # Get the detail page
                response = self.client.get(reverse('cocktail_detail', args=[test_id]))
                self.assertEqual(response.status_code, 200)
                
                # Parse HTML and check URL construction
                soup = BeautifulSoup(response.content, 'html.parser')
                favorite_button = soup.find('button', {'id': 'favorite-btn'})
                
                expected_url = reverse('toggle_favorite', args=[test_id])
                actual_url = favorite_button.get('data-favorite-url')
                
                self.assertEqual(
                    actual_url,
                    expected_url,
                    f"URL should be correctly constructed for cocktail ID {test_id}"
                )
                
                # Ensure URL doesn't have incorrect concatenation
                self.assertNotIn(f'{test_id}{test_id}', actual_url)
                self.assertTrue(actual_url.endswith(f'{test_id}/favorite/'))

    def test_favorites_button_initial_state(self):
        """
        Test that the favorite button shows the correct initial state
        based on whether the cocktail is already favorited.
        """
        self.client.login(username='testuser', password='testpass123')
        
        # Test unfavorited state
        response = self.client.get(reverse('cocktail_detail', args=[self.cocktail.id]))
        soup = BeautifulSoup(response.content, 'html.parser')
        
        favorite_button = soup.find('button', {'id': 'favorite-btn'})
        favorite_icon = soup.find('i', {'id': 'favorite-icon'})
        favorite_text = soup.find('span', {'id': 'favorite-text'})
        
        # Should show unfavorited state
        self.assertIn('btn-outline-danger', favorite_button.get('class', []))
        self.assertIn('bi-heart', favorite_icon.get('class', []))
        self.assertNotIn('bi-heart-fill', favorite_icon.get('class', []))
        self.assertEqual(favorite_text.get_text().strip(), 'Add to Favorites')
        
        # Add to favorites
        favorites_list = List.get_or_create_favorites_list(self.user)
        favorites_list.cocktails.add(self.cocktail)
        
        # Test favorited state
        response = self.client.get(reverse('cocktail_detail', args=[self.cocktail.id]))
        soup = BeautifulSoup(response.content, 'html.parser')
        
        favorite_button = soup.find('button', {'id': 'favorite-btn'})
        favorite_icon = soup.find('i', {'id': 'favorite-icon'})
        favorite_text = soup.find('span', {'id': 'favorite-text'})
        
        # Should show favorited state
        self.assertIn('btn-danger', favorite_button.get('class', []))
        self.assertIn('bi-heart-fill', favorite_icon.get('class', []))
        self.assertEqual(favorite_text.get_text().strip(), 'Remove from Favorites')

    def test_favorites_requires_authentication(self):
        """
        Test that the favorites functionality requires user authentication.
        """
        # Test without authentication
        response = self.client.post(reverse('toggle_favorite', args=[self.cocktail.id]))
        self.assertEqual(response.status_code, 302)  # Redirect to login
        
        # Test that the detail page shows different content for anonymous users
        response = self.client.get(reverse('cocktail_detail', args=[self.cocktail.id]))
        self.assertEqual(response.status_code, 200)
        
        # Anonymous users shouldn't see the favorite button
        soup = BeautifulSoup(response.content, 'html.parser')
        favorite_button = soup.find('button', {'id': 'favorite-btn'})
        self.assertIsNone(favorite_button, "Anonymous users should not see favorite button")
